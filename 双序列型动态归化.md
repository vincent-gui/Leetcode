两个一维序列或者字符串 一般数组都是(m+1) (n+1)


突破口:
	串A 与串B 的最后一个字符是否匹配
	是否需要串A或者串B 的最后一个字符
	缩减问题规模
	
	
f[i][j] : 代表序列A前i个(A[0...i-1], 序列B前j个(B[0...j-1])

初始条件和边界情况:
	空串如何处理
	基数型 考虑是否重复计算 (情况1 +  情况2 + 情况3)
	最值型 max|| min(情况1 ,情况2 ,情况3)

匹配的情况别忘了 +1 !!!!!!